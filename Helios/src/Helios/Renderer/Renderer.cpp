#include "Renderer.h"
#include "Helios/Vulkan/VulkanUtils.h"
#include <cwchar>
#include <volk/volk.h>

#include <ft2build.h>
#include FT_FREETYPE_H

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "Shader.h"

#define GLM_FORCE_RADIANS
/*
 * The perspective projection matrix generated by GLM will use the OpenGL depth
 * range of -1.0 to 1.0 by default. We need to configure it to use the Vulkan
 * range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
 */
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <filesystem>
#include <future>
#include <thread>

#include "ShaderLibrary.h"

#define STBI_NO_SIMD
#define STB_IMAGE_IMPLEMENTATION
#include "CommandBuffer.h"
#include "DescriptorPool.h"
#include "stb_image.h"

#include "Helios/Core/Application.h"
#include "Helios/Core/Core.h"
#include "Helios/Scene/PerspectiveCamera.h"
#include "Material.h"
#include "Pipeline.h"
#include "SwapChain.h"
#include "Texture.h"
#include "TextureLibrary.h"
#include "UniformBuffer.h"
#include "VertexBuffer.h"
#include "VertexBufferDescription.h"

constexpr uint32_t k_min_instances_for_mt = 500;
constexpr uint32_t k_mesh_instance_preparation_thread_count = 15;

struct QuadVertex {
    alignas(8) glm::vec2 position;
    alignas(8) glm::vec2 tex_coord;
};

struct SkyboxVertex {
    alignas(16) glm::vec3 position;
};

namespace Helios {
std::vector<QuadVertex> ui_quad_vertices = {
    {{0.0f, 0.0f}, {0.0f, 1.0f}},
    {{0.0f, 1.0f}, {0.0f, 0.0f}},
    {{1.0f, 1.0f}, {1.0f, 0.0f}},
    {{1.0f, 0.0f}, {1.0f, 1.0f}},
};

std::vector<uint32_t> ui_quad_indices = {
    0, 1, 3, 1, 2, 3,
};

std::vector<VertexAttribute> quad_vertex_attributes = {
    {VertexAttributeFormat::FLOAT2, 0}, // position
    {VertexAttributeFormat::FLOAT2, 1}, // Texture Coords
};

std::vector<VertexAttribute> quad_instance_attributes = {
    {VertexAttributeFormat::FLOAT4, 2}, // Model Col0
    {VertexAttributeFormat::FLOAT4, 3}, // Model Col1
    {VertexAttributeFormat::FLOAT4, 4}, // Model Col2
    {VertexAttributeFormat::FLOAT4, 5}, // Model Col3

    {VertexAttributeFormat::FLOAT4, 6}, // tint color
    {VertexAttributeFormat::INT32, 7},  // texture index
};

std::vector<VertexAttribute> mesh_rendering_vertex_attributes = {
    {VertexAttributeFormat::FLOAT3, 0}, // position
    {VertexAttributeFormat::FLOAT3, 1}, // normal
    {VertexAttributeFormat::FLOAT2, 2}, // Texture Coords
};

std::vector<VertexAttribute> mesh_rendering_instance_attributes = {
    {VertexAttributeFormat::FLOAT4, 3}, // Model Col0
    {VertexAttributeFormat::FLOAT4, 4}, // Model Col1
    {VertexAttributeFormat::FLOAT4, 5}, // Model Col2
    {VertexAttributeFormat::FLOAT4, 6}, // Model Col3

    {VertexAttributeFormat::INT32, 7},  // diffuse
    {VertexAttributeFormat::INT32, 8},  // specular
    {VertexAttributeFormat::INT32, 9},  // emission
    {VertexAttributeFormat::FLOAT, 10}, // shininess

    {VertexAttributeFormat::FLOAT4, 11} // tint_color
};

std::vector<VertexAttribute> skybox_vertex_attributes = {
    {VertexAttributeFormat::FLOAT3, 0}, // position
};

std::vector<SkyboxVertex> skybox_vertices = {
    {{-1.0f, -1.0f, 1.0f}}, // 0
    {{1.0f, -1.0f, 1.0f}},  // 1
    {{1.0f, 1.0f, 1.0f}},   // 2
    {{-1.0f, 1.0f, 1.0f}},  // 3

    {{-1.0f, -1.0f, -1.0f}}, // 0
    {{1.0f, -1.0f, -1.0f}},  // 1
    {{1.0f, 1.0f, -1.0f}},   // 2
    {{-1.0f, 1.0f, -1.0f}},  // 3
};

std::vector<uint32_t> skybox_indices = {
    2, 5, 1, 2, 6, 5, // Right
    4, 3, 0, 4, 7, 3, // Left
    3, 6, 2, 3, 7, 6, // Top
    0, 5, 4, 0, 1, 5, // Bottom
    4, 5, 6, 4, 6, 7, // Back
    0, 3, 1, 1, 3, 2, // Front
};

struct CameraUniformBuffer {
    alignas(16) glm::mat4 perspective_view_proj;
    alignas(16) glm::mat4 perspective_proj;
    alignas(16) glm::mat4 perspective_view_no_translation;
    alignas(16) glm::vec3 perspective_pos;

    alignas(16) glm::mat4 orthographic_proj;
};

struct LightsPushConstantCount {
    int32_t directional_light_count;
    int32_t point_light_count;
};

struct ShaderCubeMaterial {
    int diffuse_texture_unit;
    int specular_texture_unit;
    int emission_texture_unit;
    float shininess;
};

void Renderer::init(uint32_t max_frames_in_flight) {
    m_vulkan_state = &Application::get().get_vulkan_manager()->get_context();
    m_max_frames_in_flight = max_frames_in_flight;
    m_num_threads_for_instancing = k_mesh_instance_preparation_thread_count;
    m_min_instances_for_mt = k_min_instances_for_mt;

    // create the command buffers from the pool. We have one for each frame in
    // flight.
    m_command_buffers.resize(m_max_frames_in_flight);
    for (auto& m_command_buffer : m_command_buffers) {
        m_command_buffer = CommandBuffer::create();
    }

    // Load and create the default shaders. TODO: Move them outside core Helios?
    m_shaders = SharedPtr<ShaderLibrary>::create();
    load_default_shaders(m_shaders);

    // create the swap chain and the default render pass.
    recreate_swapchain();

    VulkanUtils::create_semaphores(m_vulkan_state->device,
                                   m_max_frames_in_flight,
                                   m_image_available_semaphores);
    VulkanUtils::create_semaphores(m_vulkan_state->device,
                                   m_max_frames_in_flight,
                                   m_render_available_semaphores);

    VulkanUtils::create_fences(m_vulkan_state->device, m_max_frames_in_flight,
                               m_main_fences);

    // Textures //

    m_sampler_descriptor_pool = DescriptorPool::create(
        m_max_frames_in_flight * 2,
        {VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_SAMPLER,
                              .descriptorCount = 1 * m_max_frames_in_flight},
         VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                              .descriptorCount = static_cast<uint32_t>(
                                  k_max_textures * m_max_frames_in_flight)},
         VkDescriptorPoolSize{
             .type =
                 VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, // For the skybox
             .descriptorCount = 1 * m_max_frames_in_flight,
         }});

    m_texture_sampler = TextureSampler::create_unique();

    m_texture_array_layout =
        DescriptorSetLayout::create({DescriptorSetLayoutBinding{
                                         0,
                                         VK_DESCRIPTOR_TYPE_SAMPLER,
                                         VK_SHADER_STAGE_FRAGMENT_BIT,
                                         1,
                                     },
                                     DescriptorSetLayoutBinding{
                                         1,
                                         VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                                         VK_SHADER_STAGE_FRAGMENT_BIT,
                                         k_max_textures,
                                     }});

    m_texture_arrays.resize(m_max_frames_in_flight);
    // Update the first bindings with our sampler. The second binding (for our
    // images) is updated when new textures are registered.
    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_texture_arrays[i] = DescriptorSet::create(
            m_sampler_descriptor_pool, m_texture_array_layout,
            {DescriptorSpec{
                .binding = 0,
                .type = VK_DESCRIPTOR_TYPE_SAMPLER,
                .descriptor_class = DescriptorClass::Image,
                .image_view = VK_NULL_HANDLE,
                .sampler = m_texture_sampler->get_vk_sampler(),
            }});
    }

    // Needed by the default texture creation
    m_texture_specs.resize(k_max_textures);

    m_textures = SharedPtr<TextureLibrary>::create();
    create_default_textures(m_textures);
    m_white_texture = m_textures->get_texture("WhiteTexture");
    m_black_texture = m_textures->get_texture("BlackTexture");
    m_gray_texture = m_textures->get_texture("GreyTexture");

    // Default depth image
    create_depth_image();

    // Lighting //

    m_directional_lights.resize(m_max_frames_in_flight);
    m_point_lights.resize(m_max_frames_in_flight);

    m_lights_uniform_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                              .descriptorCount = 1 * m_max_frames_in_flight},
         VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                              .descriptorCount = 1 * m_max_frames_in_flight}});

    m_lights_set_layout = DescriptorSetLayout::create(
        {DescriptorSetLayoutBinding{.binding = 0,
                                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                    .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
                                    .descriptor_count = 1},
         DescriptorSetLayoutBinding{.binding = 1,
                                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                    .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
                                    .descriptor_count = 1}});

    m_directional_lights_uniform_buffers.resize(m_max_frames_in_flight);
    m_point_lights_uniform_buffers.resize(m_max_frames_in_flight);
    m_lights_set.resize(m_max_frames_in_flight);

    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_directional_lights_uniform_buffers[i] = UniformBuffer::create_unique(
            sizeof(DirectionalLight) * k_max_directional_lights);
        m_point_lights_uniform_buffers[i] = UniformBuffer::create_unique(
            sizeof(PointLight) * k_max_point_lights);

        m_lights_set[i] = DescriptorSet::create_unique(
            m_lights_uniform_pool, m_lights_set_layout,
            {
                DescriptorSpec{
                    .binding = 0,
                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                    .descriptor_class = DescriptorClass::Buffer,
                    .buffer =
                        m_directional_lights_uniform_buffers[i]->get_buffer(),
                    .descriptor_count = 1},
                DescriptorSpec{
                    .binding = 1,
                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                    .descriptor_class = DescriptorClass::Buffer,
                    .buffer = m_point_lights_uniform_buffers[i]->get_buffer(),
                    .descriptor_count = 1},
            });
    }

    m_meshes_vertices_description = VertexBufferDescription(
        VertexInputRate::Vertex, 0, mesh_rendering_vertex_attributes);
    m_mesh_rendering_instance_vertices_description = VertexBufferDescription(
        VertexInputRate::Instance, 1, mesh_rendering_instance_attributes);

    // Instancing
    m_mesh_rendering_instances.resize(m_max_frames_in_flight);
    m_mesh_rendering_shader_instances.resize(m_max_frames_in_flight);
    m_mesh_rendering_instances_buffers.resize(m_max_frames_in_flight);

    for (uint32_t i = 0; i < m_max_frames_in_flight; i++) {
        m_mesh_rendering_instances_buffers[i] = VertexBuffer::create(
            nullptr, sizeof(MeshRenderingShaderInstanceData) * k_max_meshes);
    }

    // Cube //
    m_cube_mesh = Application::get().get_asset_manager().get_mesh("Cube");

    // Lastly, set up the pipelines for our different default drawable objects.
    setup_camera_uniform();
    setup_lighting_pipeline();
    setup_skybox_pipeline();
    setup_ui_quad_pipeline();
    create_ui_camera();

    load_fonts();
}

void Renderer::shutdown() {
    m_shutting_down = true;
    // Wait for all the pending resources
    vkDeviceWaitIdle(m_vulkan_state->device);

    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        vkDestroySemaphore(m_vulkan_state->device,
                           m_image_available_semaphores[i], nullptr);
        vkDestroySemaphore(m_vulkan_state->device,
                           m_render_available_semaphores[i], nullptr);
        vkDestroyFence(m_vulkan_state->device, m_main_fences[i], nullptr);
    }
}

void Renderer::begin_rendering(const BeginRenderingSpec& spec) {
    uint32_t width =
        spec.width == 0 ? m_swapchain->get_vk_extent().width : spec.width;
    uint32_t height =
        spec.height == 0 ? m_swapchain->get_vk_extent().height : spec.height;

    VkRenderingAttachmentInfoKHR color_attachment_info{};
    color_attachment_info.sType =
        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;
    color_attachment_info.clearValue.color = {
        spec.color_clear_value.r, spec.color_clear_value.g,
        spec.color_clear_value.b, spec.color_clear_value.a};
    color_attachment_info.loadOp = spec.color_load_op;
    color_attachment_info.storeOp = spec.color_store_op;
    color_attachment_info.imageLayout = spec.color_image_layout;

    VkImage color_image;
    if (spec.color_image == nullptr) {
        color_attachment_info.imageView =
            m_swapchain->get_vk_image_view(m_current_image_index);
        color_image = m_swapchain->get_vk_image(m_current_image_index);
    } else {
        color_attachment_info.imageView = spec.color_image->get_vk_image_view();
        color_image = spec.color_image->get_vk_image();
    }

    // Synchronize from previous begin_rendering??
    VulkanUtils::transition_image_layout(
        {.image = color_image,
         .old_layout = spec.color_image_layout,
         .new_layout = spec.color_image_layout,
         .src_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .dst_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dependency_flags = VK_DEPENDENCY_BY_REGION_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    VkRenderingAttachmentInfoKHR depth_attachment_info{};
    depth_attachment_info.sType =
        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;
    depth_attachment_info.loadOp = spec.depth_load_op;
    depth_attachment_info.storeOp = spec.depth_store_op;
    depth_attachment_info.imageLayout =
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    depth_attachment_info.clearValue.depthStencil = {spec.depth_clear_value,
                                                     spec.stencil_clear_value};

    VkImage depth_image;
    if (spec.depth_image == nullptr) {
        depth_attachment_info.imageView = m_depth_image->get_vk_image_view();
        depth_image = m_depth_image->get_vk_image();
    } else {
        depth_attachment_info.imageView = spec.depth_image->get_vk_image_view();
        depth_image = spec.depth_image->get_vk_image();
    }

    // Synchronize from previous begin_rendering??
    VulkanUtils::transition_image_layout(
        {.image = depth_image,
         .old_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .new_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .src_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
         .dst_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
         .dependency_flags = VK_DEPENDENCY_BY_REGION_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    VkRenderingInfoKHR render_info{};
    render_info.sType = VK_STRUCTURE_TYPE_RENDERING_INFO_KHR;
    render_info.renderArea = VkRect2D{VkOffset2D{}, VkExtent2D{width, height}};
    render_info.layerCount = 1;
    render_info.colorAttachmentCount = 1;
    render_info.pColorAttachments = &color_attachment_info;
    render_info.pDepthAttachment = &depth_attachment_info;

    VulkanUtils::cmd_begin_rendering_khr(
        m_vulkan_state->instance,
        m_command_buffers[m_current_frame]->get_command_buffer(), &render_info);

    VkViewport viewport{};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width = static_cast<float>(width);
    viewport.height = static_cast<float>(height);
    viewport.minDepth = 1.0f;
    viewport.maxDepth = 0.0f;
    vkCmdSetViewport(m_command_buffers[m_current_frame]->get_command_buffer(),
                     0, 1, &viewport);

    VkRect2D scissor{};
    scissor.offset = {0, 0};
    scissor.extent = VkExtent2D{width, height};
    vkCmdSetScissor(m_command_buffers[m_current_frame]->get_command_buffer(), 0,
                    1, &scissor);
}

void Renderer::end_rendering() {
    VulkanUtils::cmd_end_rendering_khr(
        m_vulkan_state->instance,
        m_command_buffers[m_current_frame]->get_command_buffer());
}

void Renderer::submit_mesh_instances(
    const BeginRenderingSpec& begin_rendering_spec) {
    // Update the current mesh instance buffer
    if (!m_mesh_rendering_shader_instances[m_current_frame].empty()) {
        // Copy the buffer

        memcpy(m_instance_staging_buffer->get_mapped_memory(),
               m_mesh_rendering_shader_instances[m_current_frame].data(),
               sizeof(MeshRenderingShaderInstanceData) *
                   m_mesh_rendering_shader_instances[m_current_frame].size());

        VulkanUtils::copy_buffer(
            m_instance_staging_buffer->get_vk_buffer(),
            m_mesh_rendering_instances_buffers[m_current_frame]
                ->get_vk_buffer(),
            sizeof(MeshRenderingShaderInstanceData) *
                m_mesh_rendering_shader_instances[m_current_frame].size(),
            m_vulkan_state->device, VK_NULL_HANDLE, VK_NULL_HANDLE,
            VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
            m_command_buffers[m_current_frame]->get_command_buffer());
    }

    // Update the lighting

    memcpy(m_directional_lights_uniform_buffers[m_current_frame]
               ->get_mapped_data(),
           m_directional_lights[m_current_frame].data(),
           sizeof(DirectionalLight) *
               m_directional_lights[m_current_frame].size());

    memcpy(m_point_lights_uniform_buffers[m_current_frame]->get_mapped_data(),
           m_point_lights[m_current_frame].data(),
           sizeof(PointLight) * m_point_lights[m_current_frame].size());

    begin_rendering(begin_rendering_spec);
    {
        draw_meshes();
    }
    end_rendering();

    m_mesh_rendering_instances[m_current_frame].clear();
    m_mesh_rendering_shader_instances[m_current_frame].clear();

    m_directional_lights[m_current_frame].clear();
    m_point_lights[m_current_frame].clear();
}

void Renderer::submit_ui_quad_instances(
    const BeginRenderingSpec& begin_rendering_spec) {

    // Update the current quad instance buffer
    if (!m_ui_quad_shader_instances[m_current_frame].empty()) {
        // Copy the buffer

        memcpy(m_instance_staging_buffer->get_mapped_memory(),
               m_ui_quad_shader_instances[m_current_frame].data(),
               sizeof(UIQuadShaderInstanceData) *
                   m_ui_quad_shader_instances[m_current_frame].size());

        VulkanUtils::copy_buffer(
            m_instance_staging_buffer->get_vk_buffer(),
            m_ui_quad_instances_buffers[m_current_frame]->get_vk_buffer(),
            sizeof(UIQuadShaderInstanceData) *
                m_ui_quad_shader_instances[m_current_frame].size(),
            m_vulkan_state->device, VK_NULL_HANDLE, VK_NULL_HANDLE,
            VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
            VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
            m_command_buffers[m_current_frame]->get_command_buffer());
    }

    begin_rendering(begin_rendering_spec);
    {
        draw_quads();
    }
    end_rendering();

    m_ui_quad_shader_instances[m_current_frame].clear();
}

void Renderer::render_skybox(const BeginRenderingSpec& begin_rendering_spec) {
    begin_rendering(begin_rendering_spec);
    {
        vkCmdBindPipeline(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            VK_PIPELINE_BIND_POINT_GRAPHICS,
            m_skybox_pipeline->get_vk_pipeline());

        VkDeviceSize offsets[1]{0};
        vkCmdBindVertexBuffers(
            m_command_buffers[m_current_frame]->get_command_buffer(), 0, 1,
            &m_skybox_mesh->get_vertex_buffer()->get_vk_buffer(), offsets);
        vkCmdBindIndexBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            m_skybox_mesh->get_index_buffer()->get_vk_buffer(), 0,
            VK_INDEX_TYPE_UINT32);
        VkDescriptorSet sets[2]{
            m_skybox_texture_sets[m_current_frame]->get_vk_set(),
            m_camera_uniform_sets[m_current_frame]->get_vk_set()};
        vkCmdBindDescriptorSets(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            VK_PIPELINE_BIND_POINT_GRAPHICS, m_skybox_pipeline->get_vk_layout(),
            0, 2, sets, 0, 0);
        vkCmdDrawIndexed(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            m_skybox_mesh->get_index_buffer()->get_index_count(), 1, 0, 0, 0);
    }
    end_rendering();
}

void Renderer::submit_command_buffer() {
    // Check for swap chain recreation?
    end_recording();

    VkSemaphore wait_semaphores[] = {
        m_image_available_semaphores[m_current_frame]};
    VkPipelineStageFlags wait_stages[] = {
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};

    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    submit_info.waitSemaphoreCount = 1;
    submit_info.pWaitSemaphores = wait_semaphores;
    submit_info.pWaitDstStageMask = wait_stages;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers =
        &m_command_buffers[m_current_frame]->get_command_buffer();

    // A little trick, because the final queueSubmit also need the signal. Works
    // because we wait for the queue right after.
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores =
        &m_image_available_semaphores[m_current_frame];

    // Submit the commands recorded so far
    if (vkQueueSubmit(m_vulkan_state->graphics_queue, 1, &submit_info,
                      m_main_fences[m_current_frame]) != VK_SUCCESS) {
        HL_ERROR("[Renderer] Failed to submit command buffer!");
    }

    VkFence fences[] = {m_main_fences[m_current_frame]};

    vkWaitForFences(m_vulkan_state->device, 1, fences, VK_TRUE, UINT64_MAX);

    vkResetFences(m_vulkan_state->device, 1, fences);

    // begin recording again
    begin_recording(false);
}

void Renderer::begin_recording(bool clear_attachment) {
    vkResetCommandBuffer(
        m_command_buffers[m_current_frame]->get_command_buffer(), 0);

    VkCommandBufferBeginInfo begin_info{};
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

    if (vkBeginCommandBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            &begin_info) != VK_SUCCESS) {
        HL_ERROR("Failed to begin recording command buffer!");
    }

    m_is_recording = true;

    // Transition the image
    VulkanUtils::transition_image_layout(
        {.image = m_swapchain->get_vk_image(m_current_image_index),
         .old_layout = VK_IMAGE_LAYOUT_UNDEFINED,
         .new_layout = VK_IMAGE_LAYOUT_GENERAL,
         .src_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    begin_rendering({
        .color_image_layout = VK_IMAGE_LAYOUT_GENERAL,
        .color_load_op = clear_attachment ? VK_ATTACHMENT_LOAD_OP_CLEAR
                                          : VK_ATTACHMENT_LOAD_OP_LOAD,
        .color_store_op = VK_ATTACHMENT_STORE_OP_STORE,
        .depth_load_op = clear_attachment ? VK_ATTACHMENT_LOAD_OP_CLEAR
                                          : VK_ATTACHMENT_LOAD_OP_LOAD,
    });
    end_rendering();
}

void Renderer::end_recording() {
    // We don't want to call vkEndCommandBuffer if vkBeginCommandBuffer was
    // never called
    if (m_swapchain_recreated_this_frame) {
        return;
    }

    // Transition the image
    const VkImageMemoryBarrier image_memory_barrier{
        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
        .oldLayout = VK_IMAGE_LAYOUT_GENERAL,
        .newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
        .image = m_swapchain->get_vk_image(m_current_image_index),
        .subresourceRange = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1,
        }};

    vkCmdPipelineBarrier(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, // srcStageMask
        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,          // dstStageMask
        0, 0, nullptr, 0, nullptr,
        1,                    // imageMemoryBarrierCount
        &image_memory_barrier // pImageMemoryBarriers
    );

    if (vkEndCommandBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer()) !=
        VK_SUCCESS) {
        HL_ERROR("Failed to record command buffer!");
    }

    m_is_recording = false;
}

void Renderer::begin_frame() {
    m_current_frame = Application::get().get_current_frame();

    if (m_recreate_swapchain_next_frame) {
        recreate_swapchain();
        m_recreate_swapchain_next_frame = false;
    }

    VkFence fences[] = {m_main_fences[m_current_frame]};

    vkWaitForFences(m_vulkan_state->device, 1, fences, VK_TRUE, UINT64_MAX);

    VkResult result = vkAcquireNextImageKHR(
        m_vulkan_state->device, m_swapchain->get_vk_swapchain(), UINT64_MAX,
        m_image_available_semaphores[m_current_frame], VK_NULL_HANDLE,
        &m_current_image_index);

    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
        recreate_swapchain();
        m_swapchain_recreated_this_frame = true;
        return;
    } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
        HL_ERROR("Failed to acquire swap chain image");
    }

    // Only reset the fences if we are submitting work
    vkResetFences(m_vulkan_state->device, 1, fences);
}

void Renderer::end_frame() {
    // We don't want to call vkEndCommandBuffer if vkBeginCommandBuffer was
    // never called
    if (m_swapchain_recreated_this_frame) {
        m_swapchain_recreated_this_frame = false;
        return;
    }

    VkSemaphore wait_semaphores[] = {
        m_image_available_semaphores[m_current_frame]};
    VkPipelineStageFlags wait_stages[] = {
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};

    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    VkSemaphore render_available_semaphores[] = {
        m_render_available_semaphores[m_current_frame]};
    submit_info.waitSemaphoreCount = 1;
    submit_info.pWaitSemaphores = wait_semaphores;
    submit_info.pWaitDstStageMask = wait_stages;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers =
        &m_command_buffers[m_current_frame]->get_command_buffer();
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores = render_available_semaphores;

    // Now let ImGui do its thing. We have a fence to make sure the command
    // buffer is not busy later.
    if (vkQueueSubmit(m_vulkan_state->graphics_queue, 1, &submit_info,
                      m_main_fences[m_current_frame]) != VK_SUCCESS) {
        HL_ERROR("[Renderer] Failed to submit command buffer!");
    }

    VkPresentInfoKHR present_info{};
    present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

    present_info.waitSemaphoreCount = 1;
    present_info.pWaitSemaphores = render_available_semaphores;

    VkSwapchainKHR swapchains[] = {m_swapchain->get_vk_swapchain()};
    present_info.swapchainCount = 1;
    present_info.pSwapchains = swapchains;

    present_info.pImageIndices = &m_current_image_index;

    VkResult result =
        vkQueuePresentKHR(m_vulkan_state->present_queue, &present_info);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR ||
        m_framebuffer_resized) {
        recreate_swapchain();
        m_framebuffer_resized = false;
    } else if (result != VK_SUCCESS) {
        HL_ERROR("Failed to present swap chain image");
    }
}

int32_t Renderer::register_texture(const Texture& texture) {
    if (texture.is_cube_map()) {
        // TODO: Handle cube map
        return -1;
    }

    if (m_available_texture_index == k_max_textures) {
        HL_ERROR("Maximum number of textures reached ({}).", k_max_textures);
        return -1;
    }

    m_texture_specs[m_available_texture_index] =
        DescriptorSpec{.binding = 1,
                       .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                       .descriptor_class = DescriptorClass::Image,
                       .image_view = texture.get_image()->get_vk_image_view(),
                       .dst_array_element = m_available_texture_index};

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        // We also defer for the current frame because otherwise the command
        // buffer complains
        Application::get().get_vulkan_manager()->enqueue_deferred_action(
            static_cast<uint32_t>(i), [&, i] {
                m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
            });
    }

    m_available_texture_index++;

    return static_cast<int32_t>(m_available_texture_index - 1);
}

void Renderer::deregister_texture(uint32_t textureIndex) {
    // Prevent deregistering textures on program destruction
    if (m_shutting_down) {
        return;
    }

    m_texture_specs[textureIndex] = DescriptorSpec{
        .binding = 1,
        .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        .descriptor_class = DescriptorClass::Image,
        .image_view = m_white_texture->get_image()->get_vk_image_view(),
        .dst_array_element = textureIndex};

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        Application::get().get_vulkan_manager()->enqueue_deferred_action(
            static_cast<uint32_t>(i), [&, i] {
                m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
            });
    }
}

void Renderer::draw_ui_quad(const Transform& transform, const glm::vec4& color,
                            const SharedPtr<Texture>& texture) {
    m_ui_quad_shader_instances[m_current_frame].push_back({
        .model = transform.ToMat4(),
        .tint_color = color,
        .texture_unit = texture ? texture->GetTextureIndex()
                                : m_gray_texture->GetTextureIndex(),
    });
}

void Renderer::draw_cube(const std::vector<MeshRenderingInstance>& instances) {
    draw_mesh(m_cube_mesh, instances);
}

std::vector<MeshRenderingShaderInstanceData>
prepare_mesh_shader_instances_mt(std::vector<MeshRenderingInstance>&& instances,
                                 SharedPtr<Texture> gray_texture,
                                 SharedPtr<Texture> black_texture) {

    std::vector<MeshRenderingShaderInstanceData> data;
    for (auto& instance : instances) {
        data.push_back({
            .model = instance.transform.ToMat4(),
            .material =
                ShaderMaterial{
                    .diffuse_texture_unit =
                        instance.material == nullptr ||
                                instance.material->get_diffuse() == nullptr
                            ? gray_texture->GetTextureIndex()
                            : instance.material->get_diffuse()
                                  ->GetTextureIndex(),
                    .specular_texture_unit =
                        instance.material == nullptr ||
                                instance.material->get_specular() == nullptr
                            ? black_texture->GetTextureIndex()
                            : instance.material->get_specular()
                                  ->GetTextureIndex(),
                    .emission_texture_unit =
                        instance.material == nullptr ||
                                instance.material->get_emission() == nullptr
                            ? black_texture->GetTextureIndex()
                            : instance.material->get_emission()
                                  ->GetTextureIndex(),
                    .shininess = instance.material == nullptr
                                     ? 32.0f
                                     : instance.material->get_shininess(),
                },
            .tint_color = instance.tint_color,
        });
    }

    return data;
}

void Renderer::draw_mesh(const SharedPtr<Mesh>& geometry,
                         const std::vector<MeshRenderingInstance>& instances,
                         const CustomMeshPipelineInfo& custom_pipeline_info) {
    m_mesh_rendering_instances[m_current_frame].push_back({
        .mesh = geometry,
        .custom_pipeline_info = custom_pipeline_info,
        .offset = sizeof(MeshRenderingShaderInstanceData) *
                  m_mesh_rendering_shader_instances[m_current_frame].size(),
        .instance_count = instances.size(),
    });

    if (instances.size() >= m_min_instances_for_mt &&
        m_num_threads_for_instancing > 1) {
        uint32_t instances_per_thread =
            instances.size() / m_num_threads_for_instancing;
        uint32_t remainder = instances.size() % m_num_threads_for_instancing;

        uint32_t offset = 0;
        uint32_t instances_prepared = 0;

        std::vector<std::future<std::vector<MeshRenderingShaderInstanceData>>>
            futures(m_num_threads_for_instancing);
        std::vector<std::vector<MeshRenderingInstance>> instance_batches(
            m_num_threads_for_instancing);
        for (uint32_t i = 0; i < m_num_threads_for_instancing; i++) {

            uint32_t num_instances_to_prepare =
                instances_per_thread +
                (i < remainder ? 1 : 0); // Distribute the remainder until done

            auto start = instances.begin() + offset;
            auto end = start + num_instances_to_prepare;
            instance_batches[i] =
                std::vector<MeshRenderingInstance>(start, end);

            futures[i] =
                std::async(std::launch::async, prepare_mesh_shader_instances_mt,
                           std::move(instance_batches[i]), m_gray_texture,
                           m_black_texture);

            instances_prepared += num_instances_to_prepare;
            offset += num_instances_to_prepare;
        }

        for (auto& future : futures) {
            auto instances = future.get();
            m_mesh_rendering_shader_instances[m_current_frame].insert(
                m_mesh_rendering_shader_instances[m_current_frame].end(),
                instances.begin(), instances.end());
        }
    } else {
        // Prepare the instances
        for (auto& instance : instances) {
            m_mesh_rendering_shader_instances[m_current_frame].push_back({
                .model = instance.transform.ToMat4(),
                .material =
                    ShaderMaterial{
                        .diffuse_texture_unit =
                            instance.material == nullptr ||
                                    instance.material->get_diffuse() == nullptr
                                ? m_gray_texture->GetTextureIndex()
                                : instance.material->get_diffuse()
                                      ->GetTextureIndex(),
                        .specular_texture_unit =
                            instance.material == nullptr ||
                                    instance.material->get_specular() == nullptr
                                ? m_black_texture->GetTextureIndex()
                                : instance.material->get_specular()
                                      ->GetTextureIndex(),
                        .emission_texture_unit =
                            instance.material == nullptr ||
                                    instance.material->get_emission() == nullptr
                                ? m_black_texture->GetTextureIndex()
                                : instance.material->get_emission()
                                      ->GetTextureIndex(),
                        .shininess = instance.material == nullptr
                                         ? 32.0f
                                         : instance.material->get_shininess(),
                    },
                .tint_color = instance.tint_color,
            });
        }
    }
}

void Renderer::set_perspective_camera(const PerspectiveCamera& camera) {
    m_perspective_camera = camera;
}

void Renderer::render_directional_light(const DirectionalLight& dir_light) {
    m_directional_lights[m_current_frame].push_back(dir_light);
}

void Renderer::render_point_light(const PointLight& point_light) {
    m_point_lights[m_current_frame].push_back(point_light);
}

void Renderer::render_text(const std::string& text, const glm::vec2& position,
                           float scale, const glm::vec4& tint_color) {
    if (!m_selected_font) {
        return;
    }

    float x_cursor = position.x;

    for (auto c = text.begin(); c != text.end(); ++c) {
        const Character& ch = m_selected_font->get_charater(*c);

        float x_pos = x_cursor + static_cast<float>(ch.bearing.x);
        float y_pos = position.y + static_cast<float>(ch.size.y - ch.bearing.y);

        float w = static_cast<float>(ch.size.x) * scale;
        float h = static_cast<float>(ch.size.y) * scale;

        Transform transform{
            .position = {x_pos, y_pos, 0.0f},
            .scale = {w, h, 1.0f},
        };

        draw_ui_quad(transform, tint_color, ch.texture);

        x_cursor += static_cast<float>(ch.advance >> 6) *
                    scale; // bitshift by 6 to get value in pixels (2^6 = 64)
    }
}

SharedPtr<Texture> Renderer::get_texture(const std::string& key) {
    if (key.empty()) {
        HL_ERROR("Empty key when in Renderer::CreateOrGetTexture(). Returning "
                 "nullptr.");
        return nullptr;
    }

    auto texture = m_textures->get_texture(key);
    if (!texture) {
        HL_WARN(
            "Tried to get texture with key: {0}, in Renderer::get_texture(), "
            "but it does not exist. Returning nullptr.",
            key);
    }

    return texture;
}

void Renderer::draw_meshes() {
    for (auto& geometry_instances :
         m_mesh_rendering_instances[m_current_frame]) {

        if (!geometry_instances.custom_pipeline_info.pipeline) {
            // Use the normal pipeline
            vkCmdBindPipeline(
                m_command_buffers[m_current_frame]->get_command_buffer(),
                VK_PIPELINE_BIND_POINT_GRAPHICS,
                m_lighting_pipeline->get_vk_pipeline());

            VkDescriptorSet sets[] = {
                m_camera_uniform_sets[m_current_frame]->get_vk_set(),
                m_texture_arrays[m_current_frame]->get_vk_set(),
                m_lights_set[m_current_frame]->get_vk_set(),
            };

            vkCmdBindDescriptorSets(
                m_command_buffers[m_current_frame]->get_command_buffer(),
                VK_PIPELINE_BIND_POINT_GRAPHICS,
                m_lighting_pipeline->get_vk_layout(), 0, 3, sets, 0, nullptr);

            LightsPushConstantCount count{
                .directional_light_count = static_cast<int32_t>(
                    m_directional_lights[m_current_frame].size()),
                .point_light_count = static_cast<int32_t>(
                    m_point_lights[m_current_frame].size())};

            vkCmdPushConstants(
                m_command_buffers[m_current_frame]->get_command_buffer(),
                m_lighting_pipeline->get_vk_layout(),
                VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                sizeof(LightsPushConstantCount), &count);

        } else {
            vkCmdBindPipeline(
                m_command_buffers[m_current_frame]->get_command_buffer(),
                VK_PIPELINE_BIND_POINT_GRAPHICS,
                geometry_instances.custom_pipeline_info.pipeline
                    ->get_vk_pipeline());

            std::vector<VkDescriptorSet> descriptor_sets(
                geometry_instances.custom_pipeline_info.descriptor_sets.size());
            for (size_t i = 0;
                 i <
                 geometry_instances.custom_pipeline_info.descriptor_sets.size();
                 i++) {
                descriptor_sets[i] =
                    geometry_instances.custom_pipeline_info.descriptor_sets[i]
                        ->get_vk_set();
            }

            vkCmdBindDescriptorSets(
                m_command_buffers[m_current_frame]->get_command_buffer(),
                VK_PIPELINE_BIND_POINT_GRAPHICS,
                geometry_instances.custom_pipeline_info.pipeline
                    ->get_vk_layout(),
                0, descriptor_sets.size(), descriptor_sets.data(), 0, nullptr);

            if (geometry_instances.custom_pipeline_info.push_constants.size >
                0) {
                vkCmdPushConstants(
                    m_command_buffers[m_current_frame]->get_command_buffer(),
                    geometry_instances.custom_pipeline_info.pipeline
                        ->get_vk_layout(),
                    geometry_instances.custom_pipeline_info.push_constants
                        .stages,
                    0,
                    geometry_instances.custom_pipeline_info.push_constants.size,
                    geometry_instances.custom_pipeline_info.push_constants.data
                        .data());
            }
        }

        VkBuffer buffers[2] = {
            geometry_instances.mesh->get_vertex_buffer()->get_vk_buffer(),
            m_mesh_rendering_instances_buffers[m_current_frame]
                ->get_vk_buffer()};
        VkDeviceSize offsets[2] = {0, geometry_instances.offset};
        vkCmdBindVertexBuffers(
            m_command_buffers[m_current_frame]->get_command_buffer(), 0, 2,
            buffers, offsets);

        vkCmdBindIndexBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            geometry_instances.mesh->get_index_buffer()->get_vk_buffer(), 0,
            VK_INDEX_TYPE_UINT32);

        vkCmdDrawIndexed(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            geometry_instances.mesh->get_index_buffer()->get_index_count(),
            static_cast<uint32_t>(geometry_instances.instance_count), 0, 0, 0);
    }
}

void Renderer::draw_quads() {
    if (m_ui_quad_shader_instances[m_current_frame].empty()) {
        return;
    }

    update_camera_uniform();

    vkCmdBindPipeline(m_command_buffers[m_current_frame]->get_command_buffer(),
                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                      m_ui_quad_pipeline->get_vk_pipeline());

    VkBuffer buffers[2]{
        m_ui_quad_mesh->get_vertex_buffer()->get_vk_buffer(),
        m_ui_quad_instances_buffers[m_current_frame]->get_vk_buffer(),
    };
    VkDeviceSize offsets[2] = {0, 0};

    vkCmdBindVertexBuffers(
        m_command_buffers[m_current_frame]->get_command_buffer(), 0, 2, buffers,
        offsets);

    vkCmdBindIndexBuffer(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        m_ui_quad_mesh->get_index_buffer()->get_vk_buffer(), 0,
        VK_INDEX_TYPE_UINT32);

    VkDescriptorSet sets[2] = {
        m_texture_arrays[m_current_frame]->get_vk_set(),
        m_camera_uniform_sets[m_current_frame]->get_vk_set()};

    vkCmdBindDescriptorSets(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        VK_PIPELINE_BIND_POINT_GRAPHICS, m_ui_quad_pipeline->get_vk_layout(), 0,
        2, sets, 0, nullptr);

    vkCmdDrawIndexed(m_command_buffers[m_current_frame]->get_command_buffer(),
                     m_ui_quad_mesh->get_index_buffer()->get_index_count(),
                     static_cast<uint32_t>(
                         m_ui_quad_shader_instances[m_current_frame].size()),
                     0, 0, 0);
}

void Renderer::create_default_textures(
    const SharedPtr<TextureLibrary>& texture_lib) {
    unsigned char data[4];
    for (int i = 0; i < 1 * 1 * 4; i++) {
        data[i] = 255;
    }

    auto texture = Texture::create("WhiteTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);

    // Now update all the slots with the default white texture
    for (uint32_t i = 0; i < k_max_textures; i++) {
        m_texture_specs[i] = DescriptorSpec{
            .binding = 1,
            .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            .descriptor_class = DescriptorClass::Image,
            .image_view = texture->get_image()->get_vk_image_view(),
            .dst_array_element = i};
    }

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
    }

    // Now create the rest of the textures
    for (int i = 0; i < 1 * 1 * 4; i++) {
        data[i] = 0;
    }

    texture = Texture::create("BlackTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);

    data[0] = 128;
    data[1] = 128;
    data[2] = 128;
    data[3] = 255;

    texture = Texture::create("GreyTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);
}

void Renderer::load_default_shaders(
    const SharedPtr<ShaderLibrary>& shader_lib) {
    std::filesystem::directory_iterator iter;

    // Check if the directory exists
    try {
        iter =
            std::filesystem::directory_iterator(RESOURCES_PATH "shaders/bin");
    } catch (...) {
        HL_WARN("No default shaders detected.");
        return;
    }

    // get all files with a .vert extension
    for (const auto& entry : iter) {
        if ((entry.path().has_extension() &&
             entry.path().extension() == ".vert") ||
            (entry.path().has_extension() &&
             entry.path().extension() == ".frag")) {
            SharedPtr<Shader> shader = Shader::create(
                entry.path().filename().string(), entry.path().string());
            shader_lib->add_shader(shader);
        }
    }
}

void Renderer::setup_ui_quad_pipeline() {
    m_ui_quad_mesh = Mesh::create(
        "UIQuad", ui_quad_vertices.data(),
        sizeof(QuadVertex) * ui_quad_vertices.size(), ui_quad_indices.data(),
        sizeof(uint32_t) * ui_quad_indices.size(), ui_quad_indices.size());

    m_ui_quad_vertex_shader = m_shaders->get_shader("ui_quad.vert");
    m_ui_quad_fragment_shader = m_shaders->get_shader("ui_quad.frag");

    m_ui_quad_uniform_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {
            VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                                 .descriptorCount = static_cast<uint32_t>(
                                     m_max_frames_in_flight)},
        });

    m_ui_quad_vertices_description = VertexBufferDescription(
        VertexInputRate::Vertex, 0, quad_vertex_attributes);
    m_ui_quad_instance_vertices_description = VertexBufferDescription(
        VertexInputRate::Instance, 1, quad_instance_attributes);

    m_ui_quad_shader_instances.resize(m_max_frames_in_flight);
    m_ui_quad_instances_buffers.resize(m_max_frames_in_flight);

    for (uint32_t i = 0; i < m_max_frames_in_flight; i++) {
        m_ui_quad_instances_buffers[i] = VertexBuffer::create(
            nullptr, sizeof(UIQuadShaderInstanceData) * k_max_ui_quads);
    }

    m_ui_quad_pipeline = Pipeline::create_unique(
        {.color_attachment_format = m_swapchain->get_vk_format(),
         .descriptor_set_layouts = {m_texture_array_layout,
                                    m_camera_uniform_set_layout},
         .vertex_shader = m_ui_quad_vertex_shader,
         .fragment_shader = m_ui_quad_fragment_shader,
         .vertex_buffer_descriptions =
             {m_ui_quad_vertices_description,
              m_ui_quad_instance_vertices_description},
         .color_blend_attachments = {VkPipelineColorBlendAttachmentState{
             .blendEnable = VK_TRUE,
             .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
             .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
             .colorBlendOp = VK_BLEND_OP_ADD,
             .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
             .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
             .alphaBlendOp = VK_BLEND_OP_ADD,
             .colorWriteMask =
                 VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                 VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT,

         }}});
}

void Renderer::setup_lighting_pipeline() {
    m_instance_staging_buffer = Buffer::create_unique(
        sizeof(MeshRenderingShaderInstanceData) * k_max_meshes,
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        true);

    m_lighting_vertex_shader = m_shaders->get_shader("Lighting.vert");
    m_lighting_fragment_shader = m_shaders->get_shader("Lighting.frag");

    m_default_lighting_pipeline_create_info = PipelineCreateInfo{
        m_swapchain->get_vk_format(),
        {m_camera_uniform_set_layout, m_texture_array_layout,
         m_lights_set_layout},
        m_lighting_vertex_shader,
        m_lighting_fragment_shader,
        {m_meshes_vertices_description,
         m_mesh_rendering_instance_vertices_description},
        {
            VkPushConstantRange{.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
                                .offset = 0,
                                .size = sizeof(LightsPushConstantCount)},
        },
    };

    m_lighting_pipeline =
        Pipeline::create(m_default_lighting_pipeline_create_info);
}

void Renderer::setup_skybox_pipeline() {
    m_skybox_vertex_shader = m_shaders->get_shader("skybox.vert");
    m_skybox_fragment_shader = m_shaders->get_shader("skybox.frag");

    m_skybox_texture_sampler = TextureSampler::create_unique();
    m_skybox_texture_layout =
        DescriptorSetLayout::create({DescriptorSetLayoutBinding{
            0,
            VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            VK_SHADER_STAGE_FRAGMENT_BIT,
            1,
        }});

    m_skybox_texture = Texture::create(CubeMapInfo{
        .right = RESOURCES_PATH "skybox/right.jpg",
        .left = RESOURCES_PATH "skybox/left.jpg",
        .top = RESOURCES_PATH "skybox/top.jpg",
        .bottom = RESOURCES_PATH "skybox/bottom.jpg",
        .back = RESOURCES_PATH "skybox/back.jpg",
        .front = RESOURCES_PATH "skybox/front.jpg",
    });

    m_skybox_texture_sets.resize(m_max_frames_in_flight);
    for (size_t i = 0; i < m_skybox_texture_sets.size(); i++) {
        m_skybox_texture_sets[i] = DescriptorSet::create(
            m_sampler_descriptor_pool, m_skybox_texture_layout,
            {DescriptorSpec{
                .binding = 0,
                .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                .descriptor_class = DescriptorClass::Image,
                .image_view =
                    m_skybox_texture->get_image()->get_vk_image_view(),
                .sampler = m_skybox_texture_sampler->get_vk_sampler(),
            }});
    }

    m_skybox_vertex_buffer_description = VertexBufferDescription(
        VertexInputRate::Vertex, 0, skybox_vertex_attributes);

    m_skybox_mesh = Mesh::create(
        "Skybox", skybox_vertices.data(),
        sizeof(SkyboxVertex) * skybox_vertices.size(), skybox_indices.data(),
        sizeof(uint32_t) * skybox_indices.size(), skybox_indices.size());

    m_skybox_pipeline = Pipeline::create(
        {m_swapchain->get_vk_format(),
         {m_skybox_texture_layout, m_camera_uniform_set_layout},
         m_skybox_vertex_shader,
         m_skybox_fragment_shader,
         {
             m_skybox_vertex_buffer_description,
         }});
}

void Renderer::setup_camera_uniform() {
    m_camera_uniform_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {
            VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                 .descriptorCount = static_cast<uint32_t>(
                                     m_max_frames_in_flight)},
        });

    m_camera_uniform_set_layout = DescriptorSetLayout::create({
        DescriptorSetLayoutBinding{
            .binding = 0,
            .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            .stage = VK_SHADER_STAGE_VERTEX_BIT,
            .descriptor_count = 1,
        },
    });

    m_camera_uniform_buffers.resize(m_max_frames_in_flight);
    m_camera_uniform_sets.resize(m_max_frames_in_flight);
    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_camera_uniform_buffers[i] =
            UniformBuffer::create_unique(sizeof(CameraUniformBuffer));
        m_camera_uniform_sets[i] = DescriptorSet::create(
            m_camera_uniform_pool, m_camera_uniform_set_layout,
            {
                DescriptorSpec{.binding = 0,
                               .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                               .descriptor_class = DescriptorClass::Buffer,
                               .buffer =
                                   m_camera_uniform_buffers[i]->get_buffer()},
            });
    }
}

void Renderer::recreate_swapchain() {
    int width = 0, height = 0;
    glfwGetFramebufferSize(Application::get().get_native_window(), &width,
                           &height);
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(Application::get().get_native_window(), &width,
                               &height);
        glfwWaitEvents();
    }

    // Wait for all the queues
    vkDeviceWaitIdle(m_vulkan_state->device);

    // Destroy and recreate the swap chain, image views
    m_swapchain.reset();
    m_swapchain = SwapChain::create(m_vsync);

    // And also the depth image
    create_depth_image();

    create_ui_camera();
}

void Renderer::update_camera_uniform() {
    CameraUniformBuffer ubo{
        .perspective_view_proj = m_perspective_camera.view_projection_matrix,
        .perspective_proj = m_perspective_camera.projection_matrix,
        .perspective_view_no_translation =
            m_perspective_camera.view_no_translation_matrix,
        .perspective_pos = m_perspective_camera.position,
        .orthographic_proj = m_ui_projection,
    };

    memcpy(m_camera_uniform_buffers[m_current_frame]->get_mapped_data(), &ubo,
           sizeof(CameraUniformBuffer));
}

void Renderer::load_fonts() {
    m_font_library.init();
    auto font = m_font_library.load_font(RESOURCES_PATH "fonts/arial.ttf");
    font->set_pixel_size(0, 48);
    font->load_characters();

    font = m_font_library.load_font(RESOURCES_PATH
                                    "fonts/JetBrainsMono-Regular.ttf");
    font->set_pixel_size(0, 48);
    font->load_characters();

    m_selected_font = font;
}

void Renderer::create_ui_camera() {
    auto size = m_swapchain->get_vk_extent();
    m_ui_projection =
        glm::orthoRH_ZO(0.0f, static_cast<float>(size.width), 0.0f,
                        static_cast<float>(size.height), 0.0f, 1.0f);
}

void Renderer::create_depth_image() {
    m_depth_image = Image::create_unique({
        .width = m_swapchain->get_vk_extent().width,
        .height = m_swapchain->get_vk_extent().height,
        .format =
            VulkanUtils::find_depth_format(m_vulkan_state->physical_device),
        .aspect_flags = VK_IMAGE_ASPECT_DEPTH_BIT,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        .memory_property = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    });

    VkCommandBuffer command_buffer = VulkanUtils::begin_single_time_commands(
        m_vulkan_state->device, m_vulkan_state->command_pool);

    // Transition the depth image
    VulkanUtils::transition_image_layout(
        {.image = m_depth_image->get_vk_image(),
         .old_layout = VK_IMAGE_LAYOUT_UNDEFINED,
         .new_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .src_access_mask = 0,
         .dst_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
                            VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
         .command_buffer = command_buffer});

    VulkanUtils::end_single_time_commands(
        command_buffer, m_vulkan_state->device, m_vulkan_state->command_pool,
        m_vulkan_state->graphics_queue);
}
} // namespace Helios
