#include "Renderer.h"
#include "Helios/Vulkan/VulkanUtils.h"
#include <volk/volk.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "Shader.h"

#define GLM_FORCE_RADIANS
/*
 * The perspective projection matrix generated by GLM will use the OpenGL depth
 * range of -1.0 to 1.0 by default. We need to configure it to use the Vulkan
 * range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
 */
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <filesystem>

#include "ShaderLibrary.h"

#define STBI_NO_SIMD
#define STB_IMAGE_IMPLEMENTATION
#include "CommandBuffer.h"
#include "DescriptorPool.h"
#include "stb_image.h"

#include "Helios/Core/Application.h"
#include "Helios/Core/Core.h"
#include "Helios/Scene/Camera.h"
#include "Material.h"
#include "Pipeline.h"
#include "SwapChain.h"
#include "Texture.h"
#include "TextureLibrary.h"
#include "UniformBuffer.h"
#include "VertexBuffer.h"
#include "VertexBufferDescription.h"
/*
std::vector<float> quad_vertices = {
        // position      // Texture coord
        0.5f, 0.5f, 0.0f, 1.0f, 1.0f,
        0.5f, -0.5f, 0.0f, 1.0f, 0.0f,
        -0.5f, -0.5f, 0.0f, 0.0f, 0.0f,
        -0.5f, 0.5f, 0.0f, 0.0f, 1.0f,
};

std::vector<uint32_t> quad_indices = {
        0, 1, 2,
        0, 2, 3,
};
*/
namespace Helios {
std::vector<float> quad_vertices = {
    // Positions            // Normals             // Texture Coords
    // Front face
    -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, // 0
    0.5f, -0.5f, -0.5f, 1.0f, 0.0f,  // 1
    0.5f, 0.5f, -0.5f, 1.0f, 1.0f,   // 2
    -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,  // 3
    // Back face
    0.5f, -0.5f, 0.5f, 0.0f, 0.0f,  // 4
    -0.5f, -0.5f, 0.5f, 1.0f, 0.0f, // 5
    -0.5f, 0.5f, 0.5f, 1.0f, 1.0f,  // 6
    0.5f, 0.5f, 0.5f, 0.0f, 1.0f,   // 7
    // Top face
    -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, // 8
    0.5f, 0.5f, -0.5f, 1.0f, 1.0f,  // 9
    0.5f, 0.5f, 0.5f, 1.0f, 0.0f,   // 10
    -0.5f, 0.5f, 0.5f, 0.0f, 0.0f,  // 11
    // Bottom face
    -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, // 12
    0.5f, -0.5f, -0.5f, 1.0f, 0.0f,  // 13
    0.5f, -0.5f, 0.5f, 1.0f, 1.0f,   // 14
    -0.5f, -0.5f, 0.5f, 0.0f, 1.0f,  // 15
    // Left face
    -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, // 16
    -0.5f, -0.5f, 0.5f, 1.0f, 0.0f,  // 17
    -0.5f, 0.5f, 0.5f, 1.0f, 1.0f,   // 18
    -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,  // 19
    // Right face
    0.5f, -0.5f, -0.5f, 0.0f, 0.0f, // 20
    0.5f, -0.5f, 0.5f, 1.0f, 0.0f,  // 21
    0.5f, 0.5f, 0.5f, 1.0f, 1.0f,   // 22
    0.5f, 0.5f, -0.5f, 0.0f, 1.0f   // 23
};

std::vector<uint32_t> quad_indices = {
    // Front face (revised to ensure clockwise order for visibility)
    0, 2, 3, 2, 0, 1,
    // Back face (unchanged, as it was displaying correctly)
    4, 7, 6, 6, 5, 4,
    // Top face (revised to ensure clockwise order for visibility)
    8, 10, 11, 10, 8, 9,
    // Bottom face (unchanged, as it was displaying correctly)
    12, 15, 14, 14, 13, 12,
    // Left face (unchanged, as it was displaying correctly)
    16, 19, 18, 18, 17, 16,
    // Right face (unchanged, as it was displaying correctly)
    20, 23, 22, 22, 21, 20};

std::vector<VertexAttribute> quad_vertex_attributes = {
    {VertexAttributeFormat::FLOAT3, 0}, // position
    {VertexAttributeFormat::FLOAT2, 1}, // Texture Coords
};

struct QuadUniformBuffer {
    alignas(16) glm::mat4 model;
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
    alignas(16) glm::vec3 color;
};

struct QuadPushConstant {
    int32_t texture_index;
};

std::vector<VertexAttribute> object_vertex_attributes = {
    {VertexAttributeFormat::FLOAT3, 0}, // position
    {VertexAttributeFormat::FLOAT3, 1}, // normal
    {VertexAttributeFormat::FLOAT2, 2}, // Texture Coords
};

std::vector<VertexAttribute> object_instance_attributes = {
    {VertexAttributeFormat::FLOAT4, 3}, // Model Col0
    {VertexAttributeFormat::FLOAT4, 4}, // Model Col1
    {VertexAttributeFormat::FLOAT4, 5}, // Model Col2
    {VertexAttributeFormat::FLOAT4, 6}, // Model Col3

    {VertexAttributeFormat::INT32, 7},  // diffuse
    {VertexAttributeFormat::INT32, 8},  // specular
    {VertexAttributeFormat::INT32, 9},  // emission
    {VertexAttributeFormat::FLOAT, 10}, // shininess
};

struct CameraUniformBuffer {
    alignas(16) glm::mat4 view;
    alignas(16) glm::mat4 proj;
    alignas(16) glm::vec3 pos;
};

struct LightsPushConstantCount {
    int32_t directional_light_count;
    int32_t point_light_count;
};

struct ShaderCubeMaterial {
    int diffuse_texture_unit;
    int specular_texture_unit;
    int emission_texture_unit;
    float shininess;
};

void Renderer::init(uint32_t max_frames_in_flight) {
    m_vulkan_state = &Application::get().get_vulkan_manager()->get_context();
    m_max_frames_in_flight = max_frames_in_flight;

    stbi_set_flip_vertically_on_load(true);

    // create the command buffers from the pool. We have one for each frame in
    // flight.
    m_command_buffers.resize(m_max_frames_in_flight);
    for (size_t i = 0; i < m_command_buffers.size(); i++) {
        m_command_buffers[i] = CommandBuffer::create();
    }

    // Load and create the default shaders. TODO: Move them outside core Helios?
    m_shaders = make_ref<ShaderLibrary>();
    load_default_shaders(m_shaders);

    // create the swap chain and the default render pass.
    m_swapchain = SwapChain::create();

    VulkanUtils::create_semaphores(m_vulkan_state->device,
                                   m_max_frames_in_flight,
                                   m_image_available_semaphores);
    VulkanUtils::create_semaphores(m_vulkan_state->device,
                                   m_max_frames_in_flight,
                                   m_render_available_semaphores);

    VulkanUtils::create_fences(m_vulkan_state->device, m_max_frames_in_flight,
                               m_main_fences);

    // Textures //

    m_sampler_descriptor_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_SAMPLER,
                              .descriptorCount = 1 * m_max_frames_in_flight},
         VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                              .descriptorCount = static_cast<uint32_t>(
                                  MAX_TEXTURES * m_max_frames_in_flight)}});

    m_texture_sampler = TextureSampler::create_unique();

    m_texture_array_layout =
        DescriptorSetLayout::create({DescriptorSetLayoutBinding{
                                         0,
                                         VK_DESCRIPTOR_TYPE_SAMPLER,
                                         VK_SHADER_STAGE_FRAGMENT_BIT,
                                         1,
                                     },
                                     DescriptorSetLayoutBinding{
                                         1,
                                         VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                                         VK_SHADER_STAGE_FRAGMENT_BIT,
                                         MAX_TEXTURES,
                                     }});

    m_texture_arrays.resize(m_max_frames_in_flight);
    // Update the first bindings with our sampler. The second binding (for our
    // images) is updated when new textures are registered.
    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_texture_arrays[i] = DescriptorSet::create_unique(
            m_sampler_descriptor_pool, m_texture_array_layout,
            {DescriptorSpec{
                .binding = 0,
                .type = VK_DESCRIPTOR_TYPE_SAMPLER,
                .descriptor_class = DescriptorClass::Image,
                .image_view = VK_NULL_HANDLE,
                .sampler = m_texture_sampler->get_vk_sampler(),
            }});
    }

    // Needed by the default texture creation
    m_texture_specs.resize(MAX_TEXTURES);

    m_textures = make_ref<TextureLibrary>();
    create_default_textures(m_textures);
    m_white_texture = m_textures->get_texture("WhiteTexture");
    m_black_texture = m_textures->get_texture("BlackTexture");
    m_gray_texture = m_textures->get_texture("GreyTexture");

    // Default depth image
    create_depth_image();

    // Lighting //

    m_directional_lights.resize(m_max_frames_in_flight);
    m_point_lights.resize(m_max_frames_in_flight);

    m_lights_uniform_pool = DescriptorPool::CreateUnique(
        m_max_frames_in_flight,
        {VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                              .descriptorCount = 1 * m_max_frames_in_flight},
         VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                              .descriptorCount = 1 * m_max_frames_in_flight}});

    m_lights_set_layout = DescriptorSetLayout::create(
        {DescriptorSetLayoutBinding{.binding = 0,
                                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                    .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
                                    .descriptor_count = 1},
         DescriptorSetLayoutBinding{.binding = 1,
                                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                    .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
                                    .descriptor_count = 1}});

    m_directional_lights_uniform_buffers.resize(m_max_frames_in_flight);
    m_point_lights_uniform_buffers.resize(m_max_frames_in_flight);
    m_lights_set.resize(m_max_frames_in_flight);

    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_directional_lights_uniform_buffers[i] = UniformBuffer::create_unique(
            sizeof(DirectionalLight) * MAX_DIRECTIONAL_LIGHTS);
        m_point_lights_uniform_buffers[i] =
            UniformBuffer::create_unique(sizeof(PointLight) * MAX_POINT_LIGHTS);

        m_lights_set[i] = DescriptorSet::create_unique(
            m_lights_uniform_pool, m_lights_set_layout,
            {
                DescriptorSpec{
                    .binding = 0,
                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                    .descriptor_class = DescriptorClass::Buffer,
                    .buffer =
                        m_directional_lights_uniform_buffers[i]->get_buffer(),
                    .descriptor_count = 1},
                DescriptorSpec{
                    .binding = 1,
                    .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                    .descriptor_class = DescriptorClass::Buffer,
                    .buffer = m_point_lights_uniform_buffers[i]->get_buffer(),
                    .descriptor_count = 1},
            });
    }

    m_geometries_vertices_description = VertexBufferDescription(
        VertexInputRate::Vertex, 0, object_vertex_attributes);
    m_instance_vertices_description = VertexBufferDescription(
        VertexInputRate::Instance, 1, object_instance_attributes);

    // Instancing
    m_mesh_instances.resize(m_max_frames_in_flight);
    m_mesh_shader_instances.resize(m_max_frames_in_flight);
    m_mesh_instances_buffers.resize(m_max_frames_in_flight);

    for (uint32_t i = 0; i < m_max_frames_in_flight; i++) {
        m_mesh_instances_buffers[i] = VertexBuffer::create(
            nullptr, sizeof(GeometryShaderInstanceData) * MAX_MESHES);
    }

    // Cube //
    m_cube_geometry = Application::get().get_asset_manager().get_geometry("Cube");

    // Lastly, set up the pipelines for our different default drawable objects.
    setup_quad_pipeline();
    setup_lighting_pipeline();

    // Textures //

    // stbi_set_flip_vertically_on_load(true);
}

void Renderer::shutdown() {
    // Wait for all the pending resources
    vkDeviceWaitIdle(m_vulkan_state->device);

    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        vkDestroySemaphore(m_vulkan_state->device,
                           m_image_available_semaphores[i], nullptr);
        vkDestroySemaphore(m_vulkan_state->device,
                           m_render_available_semaphores[i], nullptr);
        vkDestroyFence(m_vulkan_state->device, m_main_fences[i], nullptr);
    }
}

void Renderer::begin_rendering(const BeginRenderingSpec& spec) {
    uint32_t width =
        spec.width == 0 ? m_swapchain->get_vk_extent().width : spec.width;
    uint32_t height =
        spec.height == 0 ? m_swapchain->get_vk_extent().height : spec.height;

    VkRenderingAttachmentInfoKHR color_attachment_info{};
    color_attachment_info.sType =
        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;
    color_attachment_info.clearValue.color = {
        spec.color_clear_value.r, spec.color_clear_value.g,
        spec.color_clear_value.b, spec.color_clear_value.a};
    color_attachment_info.loadOp = spec.color_load_op;
    color_attachment_info.storeOp = spec.color_store_op;
    color_attachment_info.imageLayout = spec.color_image_layout;

    VkImage color_image;
    if (spec.color_image == nullptr) {
        color_attachment_info.imageView =
            m_swapchain->get_vk_image_view(m_current_image_index);
        color_image = m_swapchain->get_vk_image(m_current_image_index);
    } else {
        color_attachment_info.imageView = spec.color_image->get_vk_image_view();
        color_image = spec.color_image->get_vk_image();
    }

    // Synchronize from previous begin_rendering??
    VulkanUtils::transition_image_layout(
        {.image = color_image,
         .old_layout = spec.color_image_layout,
         .new_layout = spec.color_image_layout,
         .src_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .dst_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dependency_flags = VK_DEPENDENCY_BY_REGION_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    VkRenderingAttachmentInfoKHR depth_attachment_info{};
    depth_attachment_info.sType =
        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;
    depth_attachment_info.loadOp = spec.depth_load_op;
    depth_attachment_info.storeOp = spec.depth_store_op;
    depth_attachment_info.imageLayout =
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    depth_attachment_info.clearValue.depthStencil = {spec.depth_clear_value,
                                                     spec.stencil_clear_value};

    VkImage depth_image;
    if (spec.depth_image == nullptr) {
        depth_attachment_info.imageView = m_depth_image->get_vk_image_view();
        depth_image = m_depth_image->get_vk_image();
    } else {
        depth_attachment_info.imageView = spec.depth_image->get_vk_image_view();
        depth_image = spec.depth_image->get_vk_image();
    }

    // Synchronize from previous begin_rendering??
    VulkanUtils::transition_image_layout(
        {.image = depth_image,
         .old_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .new_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .src_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
         .dst_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
         .dependency_flags = VK_DEPENDENCY_BY_REGION_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    VkRenderingInfoKHR render_info{};
    render_info.sType = VK_STRUCTURE_TYPE_RENDERING_INFO_KHR;
    render_info.renderArea = VkRect2D{VkOffset2D{}, VkExtent2D{width, height}};
    render_info.layerCount = 1;
    render_info.colorAttachmentCount = 1;
    render_info.pColorAttachments = &color_attachment_info;
    render_info.pDepthAttachment = &depth_attachment_info;

    VulkanUtils::cmd_begin_rendering_khr(
        m_vulkan_state->instance,
        m_command_buffers[m_current_frame]->get_command_buffer(), &render_info);

    VkViewport viewport{};
    viewport.x = 0.0f;
    viewport.y = 0.0f;
    viewport.width = static_cast<float>(width);
    viewport.height = static_cast<float>(height);
    viewport.minDepth = 1.0f;
    viewport.maxDepth = 0.0f;
    vkCmdSetViewport(m_command_buffers[m_current_frame]->get_command_buffer(),
                     0, 1, &viewport);

    VkRect2D scissor{};
    scissor.offset = {0, 0};
    scissor.extent = VkExtent2D{width, height};
    vkCmdSetScissor(m_command_buffers[m_current_frame]->get_command_buffer(), 0,
                    1, &scissor);
}

void Renderer::end_rendering() {
    VulkanUtils::cmd_end_rendering_khr(
        m_vulkan_state->instance,
        m_command_buffers[m_current_frame]->get_command_buffer());
}

void Renderer::submit_instances(
    const BeginRenderingSpec& begin_rendering_spec) {
    // Update the current mesh instance buffer
    if (!m_mesh_shader_instances[m_current_frame].empty()) {
        // Copy the buffer

        memcpy(m_instance_staging_buffer->get_mapped_memory(),
               m_mesh_shader_instances[m_current_frame].data(),
               sizeof(GeometryShaderInstanceData) *
                   m_mesh_shader_instances[m_current_frame].size());

        VkBufferCopy copy_region{};
        copy_region.size = sizeof(GeometryShaderInstanceData) *
                           m_mesh_shader_instances[m_current_frame].size();
        vkCmdCopyBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            m_instance_staging_buffer->get_vk_buffer(),
            m_mesh_instances_buffers[m_current_frame]->get_vk_buffer(), 1,
            &copy_region);

        VkBufferMemoryBarrier buffer_memory_barrier = {};
        buffer_memory_barrier.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
        buffer_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        buffer_memory_barrier.dstAccessMask =
            VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;
        buffer_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        buffer_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        buffer_memory_barrier.buffer =
            m_mesh_instances_buffers[m_current_frame]->get_vk_buffer();
        // The buffer being accessed
        buffer_memory_barrier.offset = 0; // Offset within the buffer
        buffer_memory_barrier.size = copy_region.size;
        // Size of the memory range within the buffer, VK_WHOLE_SIZE means the
        // entire buffer

        // Insert the barrier into the command buffer
        vkCmdPipelineBarrier(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            VK_PIPELINE_STAGE_TRANSFER_BIT, // Pipeline stages the operations
                                            // occur in before the barrier
            VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, // Pipeline stages the
                                                // operations will wait on this
                                                // barrier
            0,                                  // Dependency flags
            0, nullptr,                         // No memory barriers
            1,
            &buffer_memory_barrier, // Buffer memory barrier count and pointer
            0, nullptr              // No image memory barriers
        );
    }

    // Update the lighting

    memcpy(m_directional_lights_uniform_buffers[m_current_frame]
               ->get_mapped_data(),
           m_directional_lights[m_current_frame].data(),
           sizeof(DirectionalLight) *
               m_directional_lights[m_current_frame].size());

    memcpy(m_point_lights_uniform_buffers[m_current_frame]->get_mapped_data(),
           m_point_lights[m_current_frame].data(),
           sizeof(PointLight) * m_point_lights[m_current_frame].size());

    begin_rendering(begin_rendering_spec);
    {
        draw_meshes();
    }
    end_rendering();

    m_mesh_instances[m_current_frame].clear();
    m_mesh_shader_instances[m_current_frame].clear();

    m_directional_lights[m_current_frame].clear();
    m_point_lights[m_current_frame].clear();
}

void Renderer::submit_command_buffer() {
    // Check for swap chain recreation?
    end_recording();

    VkSemaphore wait_semaphores[] = {
        m_image_available_semaphores[m_current_frame]};
    VkPipelineStageFlags wait_stages[] = {
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};

    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    submit_info.waitSemaphoreCount = 1;
    submit_info.pWaitSemaphores = wait_semaphores;
    submit_info.pWaitDstStageMask = wait_stages;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers =
        &m_command_buffers[m_current_frame]->get_command_buffer();

    // A little trick, because the final queueSubmit also need the signal. Works
    // because we wait for the queue right after.
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores =
        &m_image_available_semaphores[m_current_frame];

    // Submit the commands recorded so far
    if (vkQueueSubmit(m_vulkan_state->graphics_queue, 1, &submit_info,
                      m_main_fences[m_current_frame]) != VK_SUCCESS) {
        HL_ERROR("[Renderer] Failed to submit command buffer!");
    }

    VkFence fences[] = {m_main_fences[m_current_frame]};

    vkWaitForFences(m_vulkan_state->device, 1, fences, VK_TRUE, UINT64_MAX);

    vkResetFences(m_vulkan_state->device, 1, fences);

    // begin recording again
    begin_recording(false);
}

void Renderer::begin_recording(bool clear_attachment) {
    vkResetCommandBuffer(
        m_command_buffers[m_current_frame]->get_command_buffer(), 0);

    VkCommandBufferBeginInfo begin_info{};
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

    if (vkBeginCommandBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            &begin_info) != VK_SUCCESS) {
        HL_ERROR("Failed to begin recording command buffer!");
    }

    m_is_recording = true;

    // Transition the image
    VulkanUtils::transition_image_layout(
        {.image = m_swapchain->get_vk_image(m_current_image_index),
         .old_layout = VK_IMAGE_LAYOUT_UNDEFINED,
         .new_layout = VK_IMAGE_LAYOUT_GENERAL,
         .src_access_mask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
         .command_buffer =
             m_command_buffers[m_current_frame]->get_command_buffer()});

    begin_rendering({
        .color_image_layout = VK_IMAGE_LAYOUT_GENERAL,
        .color_load_op = clear_attachment ? VK_ATTACHMENT_LOAD_OP_CLEAR
                                          : VK_ATTACHMENT_LOAD_OP_LOAD,
        .color_store_op = VK_ATTACHMENT_STORE_OP_STORE,
        .depth_load_op = clear_attachment ? VK_ATTACHMENT_LOAD_OP_CLEAR
                                          : VK_ATTACHMENT_LOAD_OP_LOAD,
    });
    end_rendering();
}

void Renderer::end_recording() {
    // We don't want to call vkEndCommandBuffer if vkBeginCommandBuffer was
    // never called
    if (m_swapchain_recreated_this_frame) {
        return;
    }

    // Transition the image
    const VkImageMemoryBarrier image_memory_barrier{
        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
        .oldLayout = VK_IMAGE_LAYOUT_GENERAL,
        .newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
        .image = m_swapchain->get_vk_image(m_current_image_index),
        .subresourceRange = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1,
        }};

    vkCmdPipelineBarrier(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, // srcStageMask
        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,          // dstStageMask
        0, 0, nullptr, 0, nullptr,
        1,                    // imageMemoryBarrierCount
        &image_memory_barrier // pImageMemoryBarriers
    );

    if (vkEndCommandBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer()) !=
        VK_SUCCESS) {
        HL_ERROR("Failed to record command buffer!");
    }

    m_is_recording = false;
}

void Renderer::begin_frame() {
    m_current_frame = Application::get().get_current_frame();

    VkFence fences[] = {m_main_fences[m_current_frame]};

    vkWaitForFences(m_vulkan_state->device, 1, fences, VK_TRUE, UINT64_MAX);

    VkResult result = vkAcquireNextImageKHR(
        m_vulkan_state->device, m_swapchain->get_vk_swapchain(), UINT64_MAX,
        m_image_available_semaphores[m_current_frame], VK_NULL_HANDLE,
        &m_current_image_index);

    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
        recreate_swapchain();
        m_swapchain_recreated_this_frame = true;
        return;
    } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
        HL_ERROR("Failed to acquire swap chain image");
    }

    // Only reset the fences if we are submitting work
    vkResetFences(m_vulkan_state->device, 1, fences);
}

void Renderer::end_frame() {
    // We don't want to call vkEndCommandBuffer if vkBeginCommandBuffer was
    // never called
    if (m_swapchain_recreated_this_frame) {
        m_swapchain_recreated_this_frame = false;
        return;
    }

    VkSemaphore wait_semaphores[] = {
        m_image_available_semaphores[m_current_frame]};
    VkPipelineStageFlags wait_stages[] = {
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};

    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    VkSemaphore render_available_semaphores[] = {
        m_render_available_semaphores[m_current_frame]};
    submit_info.waitSemaphoreCount = 1;
    submit_info.pWaitSemaphores = wait_semaphores;
    submit_info.pWaitDstStageMask = wait_stages;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers =
        &m_command_buffers[m_current_frame]->get_command_buffer();
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores = render_available_semaphores;

    // Now let ImGui do its thing. We have a fence to make sure the command
    // buffer is not busy later.
    if (vkQueueSubmit(m_vulkan_state->graphics_queue, 1, &submit_info,
                      m_main_fences[m_current_frame]) != VK_SUCCESS) {
        HL_ERROR("[Renderer] Failed to submit command buffer!");
    }

    VkPresentInfoKHR present_info{};
    present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

    present_info.waitSemaphoreCount = 1;
    present_info.pWaitSemaphores = render_available_semaphores;

    VkSwapchainKHR swapchains[] = {m_swapchain->get_vk_swapchain()};
    present_info.swapchainCount = 1;
    present_info.pSwapchains = swapchains;

    present_info.pImageIndices = &m_current_image_index;

    VkResult result =
        vkQueuePresentKHR(m_vulkan_state->present_queue, &present_info);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR ||
        m_framebuffer_resized) {
        recreate_swapchain();
        m_framebuffer_resized = false;
    } else if (result != VK_SUCCESS) {
        HL_ERROR("Failed to present swap chain image");
    }
}

int32_t Renderer::register_texture(const Texture& texture) {
    m_texture_specs[m_available_texture_index] =
        DescriptorSpec{.binding = 1,
                       .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                       .descriptor_class = DescriptorClass::Image,
                       .image_view = texture.get_image()->get_vk_image_view(),
                       .dst_array_element = m_available_texture_index};

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        // We also defer for the current frame because otherwise the command
        // buffer complains
        Application::get().get_vulkan_manager()->enqueue_deferred_action(
            static_cast<uint32_t>(i), [&, i] {
                m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
            });
    }

    m_available_texture_index++;

    return static_cast<int32_t>(m_available_texture_index - 1);
}

void Renderer::deregister_texture(uint32_t textureIndex) {
    m_texture_specs[textureIndex] = DescriptorSpec{
        .binding = 1,
        .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
        .descriptor_class = DescriptorClass::Image,
        .image_view = m_white_texture->get_image()->get_vk_image_view(),
        .dst_array_element = textureIndex};

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        Application::get().get_vulkan_manager()->enqueue_deferred_action(
            static_cast<uint32_t>(i), [&, i] {
                m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
            });
    }
}

void Renderer::draw_quad(const Transform& transform, const glm::vec3& color,
                         const Ref<Texture>& texture) {
    QuadUniformBuffer ubo{};
    ubo.model = transform.ToMat4();
    ubo.view = m_current_camera.view_matrix;
    ubo.proj = m_current_camera.projection_matrix;
    ubo.color = color;

    memcpy(m_quad_uniform_buffers[m_current_frame]->get_mapped_data(), &ubo,
           sizeof(ubo));

    vkCmdBindPipeline(m_command_buffers[m_current_frame]->get_command_buffer(),
                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                      m_quad_pipeline->get_vk_pipeline());

    VkDeviceSize offsets[] = {0};
    vkCmdBindVertexBuffers(
        m_command_buffers[m_current_frame]->get_command_buffer(), 0, 1,
        &m_quad_geometry->get_vertex_buffer()->get_vk_buffer(), offsets);

    vkCmdBindIndexBuffer(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        m_quad_geometry->get_index_buffer()->get_vk_buffer(), 0,
        VK_INDEX_TYPE_UINT32);

    QuadPushConstant push_constants = {.texture_index =
                                           texture->GetTextureIndex()};

    vkCmdPushConstants(m_command_buffers[m_current_frame]->get_command_buffer(),
                       m_quad_pipeline->get_vk_layout(),
                       VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(push_constants),
                       &push_constants);

    VkDescriptorSet sets[] = {
        m_quad_uniform_sets[m_current_frame]->get_vk_set(),
        m_texture_arrays[m_current_frame]->get_vk_set(),
    };

    vkCmdBindDescriptorSets(
        m_command_buffers[m_current_frame]->get_command_buffer(),
        VK_PIPELINE_BIND_POINT_GRAPHICS, m_quad_pipeline->get_vk_layout(), 0, 2,
        sets, 0, nullptr);

    vkCmdDrawIndexed(m_command_buffers[m_current_frame]->get_command_buffer(),
                     static_cast<uint32_t>(quad_indices.size()), 1, 0, 0, 0);
}

void Renderer::draw_cube(const std::vector<GeometryInstance>& instances) {
    draw_mesh(m_cube_geometry, instances);
}

void Renderer::draw_mesh(const Ref<Geometry>& geometry,
                         const std::vector<GeometryInstance>& instances) {
    m_mesh_instances[m_current_frame].push_back(
        {.geometry = geometry,
         .offset = sizeof(GeometryShaderInstanceData) *
                   m_mesh_shader_instances[m_current_frame].size(),
         .instance_count = instances.size()});

    // Prepare the instances
    for (auto& instance : instances) {
        m_mesh_shader_instances[m_current_frame].push_back(
            {.model = instance.transform.ToMat4(),
             .material = ShaderMaterial{
                 .diffuse_texture_unit =
                     instance.material == nullptr ||
                             instance.material->get_diffuse() == nullptr
                         ? m_gray_texture->GetTextureIndex()
                         : instance.material->get_diffuse()->GetTextureIndex(),
                 .specular_texture_unit =
                     instance.material == nullptr ||
                             instance.material->get_specular() == nullptr
                         ? m_black_texture->GetTextureIndex()
                         : instance.material->get_specular()->GetTextureIndex(),
                 .emission_texture_unit =
                     instance.material == nullptr ||
                             instance.material->get_emission() == nullptr
                         ? m_black_texture->GetTextureIndex()
                         : instance.material->get_emission()->GetTextureIndex(),
                 .shininess = instance.material == nullptr
                                  ? 32.0f
                                  : instance.material->get_shininess(),
             }});
    }
}

void Renderer::set_camera(const Camera& camera) { m_current_camera = camera; }

void Renderer::render_directional_light(const DirectionalLight& dir_light) {
    m_directional_lights[m_current_frame].push_back(dir_light);
}

void Renderer::render_point_light(const PointLight& point_light) {
    m_point_lights[m_current_frame].push_back(point_light);
}

Ref<Texture> Renderer::get_texture(const std::string& key) {
    if (key.empty()) {
        HL_ERROR("Empty key when in Renderer::CreateOrGetTexture(). Returning "
                 "nullptr.");
        return nullptr;
    }

    auto texture = m_textures->get_texture(key);
    if (!texture) {
        HL_WARN(
            "Tried to get texture with key: {0}, in Renderer::get_texture(), "
            "but it does not exist. Returning nullptr.",
            key);
    }

    return texture;
}

void Renderer::draw_meshes() {
    CameraUniformBuffer ubo{};
    ubo.view = m_current_camera.view_matrix;
    ubo.proj = m_current_camera.projection_matrix;
    ubo.pos = m_current_camera.position;

    memcpy(m_camera_uniform_buffers[m_current_frame]->get_mapped_data(), &ubo,
           sizeof(ubo));

    vkCmdBindPipeline(m_command_buffers[m_current_frame]->get_command_buffer(),
                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                      m_lighting_pipeline->get_vk_pipeline());

    for (auto& geometry_instances : m_mesh_instances[m_current_frame]) {
        VkBuffer buffers[2] = {
            geometry_instances.geometry->get_vertex_buffer()->get_vk_buffer(),
            m_mesh_instances_buffers[m_current_frame]->get_vk_buffer()};
        VkDeviceSize offsets[2] = {0, geometry_instances.offset};
        vkCmdBindVertexBuffers(
            m_command_buffers[m_current_frame]->get_command_buffer(), 0, 2,
            buffers, offsets);

        vkCmdBindIndexBuffer(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            geometry_instances.geometry->get_index_buffer()->get_vk_buffer(), 0,
            VK_INDEX_TYPE_UINT32);

        VkDescriptorSet sets[] = {
            m_camera_uniform_sets[m_current_frame]->get_vk_set(),
            m_texture_arrays[m_current_frame]->get_vk_set(),
            m_lights_set[m_current_frame]->get_vk_set(),
        };

        vkCmdBindDescriptorSets(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            VK_PIPELINE_BIND_POINT_GRAPHICS,
            m_lighting_pipeline->get_vk_layout(), 0, 3, sets, 0, nullptr);

        LightsPushConstantCount count{
            .directional_light_count = static_cast<int32_t>(
                m_directional_lights[m_current_frame].size()),
            .point_light_count =
                static_cast<int32_t>(m_point_lights[m_current_frame].size())};

        vkCmdPushConstants(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            m_lighting_pipeline->get_vk_layout(), VK_SHADER_STAGE_FRAGMENT_BIT,
            0, sizeof(LightsPushConstantCount), &count);

        vkCmdDrawIndexed(
            m_command_buffers[m_current_frame]->get_command_buffer(),
            geometry_instances.geometry->get_index_buffer()->get_index_count(),
            static_cast<uint32_t>(geometry_instances.instance_count), 0, 0, 0);
    }
}

void Renderer::create_default_textures(const Ref<TextureLibrary>& texture_lib) {
    unsigned char data[4];
    for (int i = 0; i < 1 * 1 * 4; i++) {
        data[i] = 255;
    }

    auto texture = Texture::create("WhiteTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);

    // Now update all the slots with the default white texture
    for (uint32_t i = 0; i < MAX_TEXTURES; i++) {
        m_texture_specs[i] = DescriptorSpec{
            .binding = 1,
            .type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            .descriptor_class = DescriptorClass::Image,
            .image_view = texture->get_image()->get_vk_image_view(),
            .dst_array_element = i};
    }

    // Update all the image view descriptors, for every frame in flight
    for (size_t i = 0; i < m_texture_arrays.size(); i++) {
        m_texture_arrays[i]->update_descriptor_set(m_texture_specs);
    }

    // Now create the rest of the textures
    for (int i = 0; i < 1 * 1 * 4; i++) {
        data[i] = 0;
    }

    texture = Texture::create("BlackTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);

    data[0] = 128;
    data[1] = 128;
    data[2] = 128;
    data[3] = 255;

    texture = Texture::create("GreyTexture", data, 1, 1, sizeof(data));
    texture_lib->add_texture(texture);
}

void Renderer::load_default_shaders(const Ref<ShaderLibrary>& shader_lib) {
    std::filesystem::directory_iterator iter;

    // Check if the directory exists
    try {
        iter =
            std::filesystem::directory_iterator(RESOURCES_PATH "shaders/bin");
    } catch (...) {
        HL_WARN("No default shaders detected.");
        return;
    }

    // get all files with a .vert extension
    for (const auto& entry : iter) {
        if ((entry.path().has_extension() &&
             entry.path().extension() == ".vert") ||
            (entry.path().has_extension() &&
             entry.path().extension() == ".frag")) {
            Ref<Shader> shader = Shader::create(
                entry.path().filename().string(), entry.path().string());
            shader_lib->add_shader(shader);
        }
    }
}

void Renderer::setup_quad_pipeline() {
    m_quad_geometry = Geometry::create(
        "Quad", quad_vertices.data(), sizeof(float) * quad_vertices.size(),
        quad_indices.data(), sizeof(uint32_t) * quad_indices.size(),
        quad_indices.size());

    m_quad_vertex_shader = m_shaders->get_shader("2DTexture.vert");
    m_quad_fragment_shader = m_shaders->get_shader("2DTexture.frag");

    m_quad_uniform_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {
            VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                 .descriptorCount = static_cast<uint32_t>(
                                     m_max_frames_in_flight)},
        });

    m_quad_uniform_buffers.resize(m_max_frames_in_flight);
    m_quad_uniform_sets.resize(m_max_frames_in_flight);

    m_quad_uniform_set_layout = DescriptorSetLayout::create({
        DescriptorSetLayoutBinding{.binding = 0,
                                   .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                   .stage = VK_SHADER_STAGE_VERTEX_BIT,
                                   .descriptor_count = 1},
    });

    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_quad_uniform_buffers[i] =
            UniformBuffer::create_unique(sizeof(QuadUniformBuffer));
        m_quad_uniform_sets[i] = DescriptorSet::create_unique(
            m_quad_uniform_pool, m_quad_uniform_set_layout,
            {
                DescriptorSpec{.binding = 0,
                               .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                               .descriptor_class = DescriptorClass::Buffer,
                               .buffer =
                                   m_quad_uniform_buffers[i]->get_buffer()},
            });
    }

    m_quad_vertices_description = VertexBufferDescription(
        VertexInputRate::Vertex, 0, quad_vertex_attributes);

    m_quad_pipeline = Pipeline::create_unique({
        m_swapchain->get_vk_format(),
        {m_quad_uniform_set_layout, m_texture_array_layout},
        m_quad_vertex_shader,
        m_quad_fragment_shader,
        {m_quad_vertices_description},
        {VkPushConstantRange{
            .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
            .size = sizeof(QuadPushConstant),
        }},
    });
}

void Renderer::setup_lighting_pipeline() {
    m_instance_staging_buffer =
        Buffer::create_unique(sizeof(GeometryShaderInstanceData) * MAX_MESHES,
                              VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                              VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                                  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                              true);

    m_lighting_vertex_shader = m_shaders->get_shader("Lighting.vert");
    m_lighting_fragment_shader = m_shaders->get_shader("Lighting.frag");

    m_camera_uniform_pool = DescriptorPool::create(
        m_max_frames_in_flight,
        {
            VkDescriptorPoolSize{.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                                 .descriptorCount = static_cast<uint32_t>(
                                     m_max_frames_in_flight)},
        });

    m_camera_uniform_set_layout = DescriptorSetLayout::create({
        DescriptorSetLayoutBinding{
            .binding = 0,
            .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            .stage = VK_SHADER_STAGE_VERTEX_BIT,
            .descriptor_count = 1,
        },
    });

    m_camera_uniform_buffers.resize(m_max_frames_in_flight);
    m_camera_uniform_sets.resize(m_max_frames_in_flight);
    for (size_t i = 0; i < m_max_frames_in_flight; i++) {
        m_camera_uniform_buffers[i] =
            UniformBuffer::create_unique(sizeof(CameraUniformBuffer));
        m_camera_uniform_sets[i] = DescriptorSet::create_unique(
            m_camera_uniform_pool, m_camera_uniform_set_layout,
            {
                DescriptorSpec{.binding = 0,
                               .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                               .descriptor_class = DescriptorClass::Buffer,
                               .buffer =
                                   m_camera_uniform_buffers[i]->get_buffer()},
            });
    }

    m_lighting_pipeline = Pipeline::create_unique({
        m_swapchain->get_vk_format(),
        {m_camera_uniform_set_layout, m_texture_array_layout,
         m_lights_set_layout},
        m_lighting_vertex_shader,
        m_lighting_fragment_shader,
        {m_geometries_vertices_description, m_instance_vertices_description},
        {
            VkPushConstantRange{.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
                                .offset = 0,
                                .size = sizeof(LightsPushConstantCount)},
        },
    });
}

void Renderer::recreate_swapchain() {
    int width = 0, height = 0;
    glfwGetFramebufferSize(Application::get().get_native_window(), &width,
                           &height);
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(Application::get().get_native_window(), &width,
                               &height);
        glfwWaitEvents();
    }

    // Wait for all the queues
    vkDeviceWaitIdle(m_vulkan_state->device);

    // Destroy and recreate the swap chain, image views
    m_swapchain.reset();
    m_swapchain = SwapChain::create();

    // And also the depth image
    create_depth_image();
}

void Renderer::create_depth_image() {
    m_depth_image = Image::create_unique({
        .width = m_swapchain->get_vk_extent().width,
        .height = m_swapchain->get_vk_extent().height,
        .format =
            VulkanUtils::find_depth_format(m_vulkan_state->physical_device),
        .aspect_flags = VK_IMAGE_ASPECT_DEPTH_BIT,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        .memory_property = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    });

    VkCommandBuffer command_buffer = VulkanUtils::begin_single_time_commands(
        m_vulkan_state->device, m_vulkan_state->command_pool);

    // Transition the depth image
    VulkanUtils::transition_image_layout(
        {.image = m_depth_image->get_vk_image(),
         .old_layout = VK_IMAGE_LAYOUT_UNDEFINED,
         .new_layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
         .src_access_mask = 0,
         .dst_access_mask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
                            VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
         .src_stage_mask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
         .dst_stage_mask = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
         .command_buffer = command_buffer});

    VulkanUtils::end_single_time_commands(
        command_buffer, m_vulkan_state->device, m_vulkan_state->command_pool,
        m_vulkan_state->graphics_queue);
}
} // namespace Helios
